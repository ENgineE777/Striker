
#import "Mission"

class MeshInstance
{
    Mesh@ mesh;
    Phys3D@ phys;
    int visible = 1;
}

class Bullet
{
    Vector3 pos;
    Vector3 dir;

    Mesh@ mesh;
    int visible = 1;

    bool wait_delete = false;
    ParticleSystem@ trail;
}

class Particle
{
    Vector3 pos;
    Vector3 color;
    float radius = 0.0f;
    float timelife = 0.0f;
}

class Main
{
    Camera3D@ camera;
    array<MeshInstance> heli_body;
    array<MeshInstance> heli_main_rotor;
    array<MeshInstance> heli_tail_rotot;
    array<MeshInstance> heli_pad;

    int cur_mission = 0;
    array<Mission@> missions;

    array<EnemyPool@> pools;

    array<Bullet> bullets;
    array<Bullet> missiles;

    array<Particle> particles;

    float camera_rotate_accel = 1.25f;
    float camera_rotate_deaccel = 0.85f;
    float camera_rotate_cur_speed = 0.0f;
    float camera_rotate_speed = 1.35f;
    float camera_rotate_angle = 0.0f;
    float camera_dist_vert = 50.0f;
    float camera_dist_horz = 40.0f;
    float camera_vert_angle = -0.785489805f;

    float start_cooldown = 0.0f;

    Vector3 heli_pos;
    float   heli_angle;
    Vector2 heli_speed;

    float bullet_cooldown = 0.0f;
    float bullet_vert_angle = 0.01745329f * 17.5f;
    float bullet_speed = 75.0f;

    float missile_cooldown = 0.0f;
    int   missile_side = 0;
    float missile_speed = 70.0f;

    float heli_height = 10.0f;
    float heli_rotor_angle = 0.0f;

    float heli_rotate_accel = 12.5f;
    float heli_rotate_deaccel = 3.0f;
    float heli_rotate_speed = 2.25f;
    float heli_rotate_z_angle = 0.375f;

    float heli_forward_accel = 60.0f;
    float heli_forward_deaccel = 30.0f;
    float heli_forward_speed = 35.0f;
    float heli_forward_x_angle = 0.375f;

    float heli_backward_accel = 40.0f;
    float heli_backward_deaccel = 4.0f;
    float heli_backward_speed = 20.0f;
    float heli_backward_x_angle = 0.25f;

	int alias_move_vert = -1;
	int alias_move_horz = -1;
	int alias_fire = -1;
    int alias_missile_fire = -1;
    int alias_prev_mission = -1;
    int alias_next_mission = -1;

    Vector3 main_helipad_pos;

    bool landing = false;
    Vector3 helipad_pos;
    float time_near_landing;
    Vector3 dir_to_helipad;
    float dist_to_helipad;

    int target_enemy_pool = -1;
    int target_enemy_index = - 1;

	void OnInit()
	{
		alias_move_vert = core.controls.GetAliasIndex("Hero.MOVE_VERT");
		alias_move_horz = core.controls.GetAliasIndex("Hero.MOVE_HORZ");
		alias_fire = core.controls.GetAliasIndex("Hero.Fire");
        alias_missile_fire = core.controls.GetAliasIndex("Hero.MissileFire");
        alias_prev_mission = core.controls.GetAliasIndex("Hero.PrevMission");
        alias_next_mission = core.controls.GetAliasIndex("Hero.NextMission");

        Matrix pad_mat = heli_pad[0].mesh.GetTransform();
        heli_pos = pad_mat.GetPos();

        landing = true;
        main_helipad_pos = pad_mat.GetPos();
	}

    void RegisterEnemyPool(EnemyPool@ pool)
    {
        pools.insertLast(pool);
    }

    void RegisterMission(Mission@ pool)
    {
        missions.insertLast(pool);
    }

    void AddParticle(Vector3 pos, Vector3 color, float radius)
    {
        int index = particles.get_length();
        particles.resize(index + 1);
        Particle@ particle = particles[index];

        particle.pos = pos;
        particle.color = color;
        particle.radius = radius;
    }

    void UpdateParticles(float dt)
    {
        for (int i =  0; i < particles.get_length(); i++)
        {
            Particle@ particle = @particles[i];

            particle.timelife += dt;

            if (particle.timelife > 0.35f)
            {
                particles.removeAt(i);
				i--;
            }
            else
            {
                core.render.DebugSphere(particle.pos, particle.color, particle.radius * particle.timelife / 0.35f);
            }
        }
    }

    void UpdateAutoTargeting()
    {
        int new_target_enemy_pool = -1;
        int new_target_enemy_index = - 1;
        float dist = 10000;

        if (!landing)
        {
            for (int i = 0; i < pools.get_length(); i++)
            {
                auto@ pool = pools[i];

                if (!pool.AutoTargedAllowed())
                {
                    continue;
                }

                for (int j = 0; j < pool.enemies.get_length(); j++)
                {
                    auto@ enemy = pool.enemies[j];

                    if (enemy.hp <= 0)
                    {
                        continue;
                    }

                    auto pos = enemy.mesh.GetTransform().GetPos();
                    pos.y = heli_pos.y;

                    float cur_dir = (heli_pos - pos).Length();

                    if (cur_dir > 10.0f && cur_dir < 50.0f && cur_dir < dist &&
                        core.utils.IsPointInSector(Vector2(pos.x, pos.z), Vector2(heli_pos.x, heli_pos.z), heli_angle + 0.01745329f * 90.0f, 50.0f, 0.01745329f * 30.0f, false))
                    {
                        dist = cur_dir;
                        new_target_enemy_pool = i;
                        new_target_enemy_index = j;
                    }
                }
            }
        }

        if (new_target_enemy_pool != target_enemy_pool || new_target_enemy_index != target_enemy_index)
        {
            if (target_enemy_pool != -1)
            {
                pools[target_enemy_pool].enemies[target_enemy_index].mesh.SetColor(Vector3(1.0f));
            }

            if (new_target_enemy_pool != -1)
            {
                pools[new_target_enemy_pool].enemies[new_target_enemy_index].mesh.SetColor(Vector3(1.0f, 0.2f, 0.2f));
            }

            target_enemy_pool = new_target_enemy_pool;
            target_enemy_index = new_target_enemy_index;
        }
    }

    void UpdateHeliControl(float dt)
    {
        heli_pos.y += dt * 8.0f;

        if (heli_pos.y > heli_height)
        {
            heli_pos.y = heli_height;
        }

        float dir_y = core.controls.GetValue(alias_move_horz, 0);
        float dir_x = core.controls.GetValue(alias_move_vert, 0);

        if (abs(dir_y) > 0.1f)
        {
            heli_speed.y += dir_y * heli_rotate_accel * dt;

            if (heli_speed.y > heli_rotate_speed)
            {
                heli_speed.y = heli_rotate_speed;
            }

            if (heli_speed.y < -heli_rotate_speed)
            {
                heli_speed.y = -heli_rotate_speed;
            }
        }
        else
        {
            if (heli_speed.y > 0.0f)
            {
                heli_speed.y -= heli_rotate_deaccel * dt;

                if (heli_speed.y < 0.0f)
                {
                    heli_speed.y = 0.0f;
                }
            }
            else
            if (heli_speed.y < 0.0f)
            {
                heli_speed.y += heli_rotate_deaccel * dt;

                if (heli_speed.y > 0.0f)
                {
                    heli_speed.y = 0.0f;
                }
            }
        }

        if (abs(dir_x) > 0.1f)
        {
            heli_speed.x += dir_x * (dir_x > 0.1f ? heli_forward_accel : heli_backward_accel) * dt;

            if (heli_speed.x > heli_forward_speed)
            {
                heli_speed.x = heli_forward_speed;
            }

            if (heli_speed.x < -heli_backward_speed)
            {
                heli_speed.x = -heli_backward_speed;
            }
        }
        else
        {
            if (heli_speed.x > 0.0f)
            {
                heli_speed.x -= heli_forward_deaccel * dt;

                if (heli_speed.x < 0.0f)
                {
                    heli_speed.x = 0.0f;
                }
            }
            else
            if (heli_speed.x < 0.0f)
            {
                heli_speed.x += heli_backward_accel * dt;

                if (heli_speed.x > 0.0f)
                {
                    heli_speed.x = 0.0f;
                }
            }
        }

        heli_angle -= heli_speed.y * dt;

        heli_pos += Vector3(sin(-heli_angle), 0, cos(-heli_angle)) * heli_speed.x * dt;

        Vector3 target_pos;

        if (target_enemy_pool != -1)
        {
            target_pos = pools[target_enemy_pool].enemies[target_enemy_index].mesh.GetTransform().GetPos();
        }

        if (bullet_cooldown > 0.0f)
        {
            bullet_cooldown -= dt;
        }
        else
        {
            if (core.controls.GetState(alias_fire, 0) > 0)
            {
                int index = bullets.get_length();
                bullets.resize(index + 1);
                Bullet@ bullet = bullets[index];

                Matrix loc_matrix = heli_body[0].mesh.GetLocatorTransform("loc_gun_muzzle");
                bullet.pos = loc_matrix.GetPos();

                Matrix bullet_mat;
                bullet_mat.RotateX(bullet_vert_angle);
                bullet_mat.RotateY(-heli_angle);
                bullet_mat.SetPos(bullet.pos);

                if (target_enemy_pool != -1)
                {
                    bullet.dir = target_pos - bullet.pos;
                    bullet.dir.Normalize();
                }
                else
                {
                    bullet.dir = bullet_mat.GetVz();
                }

                bullet.mesh.SetTransform(bullet_mat);

                bullet_cooldown = 0.25f;
            }
        }

        if (missile_cooldown > 0.0f)
        {
            missile_cooldown -= dt;
        }
        else
        {
            if (core.controls.GetState(alias_missile_fire, 0) > 0)
            {
                int index = missiles.get_length();
                missiles.resize(index + 1);
                Bullet@ missile = missiles[index];

                Matrix loc_matrix = heli_body[0].mesh.GetLocatorTransform(missile_side == 1 ? "loc_missile_left" : "loc_missile_right");
                missile.pos = loc_matrix.GetPos();

                Matrix trail_mat;
                trail_mat.SetPos(missile.pos);
                
                @missile.trail = @core.scene.CreateParticles("Scene", "smokeTrail");
                missile.trail.SetTransform(trail_mat);

                Matrix missile_mat;
                missile_mat.RotateX(bullet_vert_angle);
                missile_mat.RotateY(-heli_angle);
                missile_mat.SetPos(missile.pos);

                if (target_enemy_pool != -1)
                {
                    missile.dir = target_pos - missile.pos;
                    missile.dir.Normalize();
                }
                else
                {
                    missile.dir = missile_mat.GetVz();
                }
                
                missile.mesh.SetTransform(missile_mat);

                missile_cooldown = 0.5f;

                missile_side = 1 - missile_side;
            }
        }
    }

    void CheckIfCanLand(Vector3 pos, float dt)
    {
        if (landing)
        {
            return;
        }

        Vector3 dir = heli_pos - pos;
        dir.y = 0.0f;

        if (dir.Length() < 4.0f)
        {
            core.render.DebugText(5, 30, "Landing");

            time_near_landing += dt;

            if (time_near_landing > 2.0f)
            {
                landing = true;
                helipad_pos = pos;

                dir_to_helipad = helipad_pos - heli_pos;
                dist_to_helipad = dir_to_helipad.Length();
                dir_to_helipad /= dist_to_helipad;
            }
        }
        else
        {
            time_near_landing = 0.0f;
        }
    }

    bool IsLanded()
    {
        return abs(helipad_pos.y - heli_pos.y) < 0.001f;
    }

    void TakeOff()
    {
        landing = false;
    }

    void UpdateHeli(float dt)
    {
        heli_rotor_angle += dt * 15;

        UpdateAutoTargeting();

        if (start_cooldown < 1.0f)
        {
            start_cooldown += dt * 1.0f;
            landing = false;
        }
        else
        if (landing)
        {
            heli_angle = core.utils.AdvanceAngle(heli_angle, 0.0f, 0.075f);

            heli_pos.y -= dt * 5.0f;

            if (heli_pos.y < helipad_pos.y)
            {
                heli_pos.y = helipad_pos.y;
                camera_rotate_speed = 0.0f;
                camera_rotate_angle = heli_angle;
            }

            if (dist_to_helipad > 0.001f)
            {
                dist_to_helipad -= dt * 15.0f;

                if (dist_to_helipad < 0.0f)
                {
                    helipad_pos = heli_pos;
                }
                else
                {
                    heli_pos += dir_to_helipad * dt * 15.0f;
                }
            }
        }
        else
        {
            UpdateHeliControl(dt);
        }

        if (core.controls.GetState(alias_next_mission, 1) > 0)
        {
            NextMission();
        }
        else
        if (core.controls.GetState(alias_prev_mission, 1) > 0)
        {
            NextMission(false);
        }

        Matrix rotateZ;
        rotateZ.RotateZ(-heli_speed.y / heli_rotate_speed * heli_rotate_z_angle);

        Matrix rotateX;
        rotateZ.RotateX(heli_speed.x > 0.0f ? (heli_speed.x / heli_forward_speed * heli_forward_x_angle) : (heli_speed.x / heli_backward_speed * heli_backward_x_angle));

        Matrix heli_mat;
        heli_mat.RotateY(-heli_angle);
        heli_mat = rotateZ * rotateX * heli_mat;
        heli_mat.SetPos(heli_pos);

        heli_body[0].mesh.SetTransform(heli_mat);

        Matrix loc_matrix = heli_body[0].mesh.GetLocatorTransform("loc_main_rotor");
        Matrix main_rotor_rot;
        main_rotor_rot.RotateY(heli_rotor_angle);

        heli_main_rotor[0].mesh.SetTransform(main_rotor_rot * loc_matrix);

        loc_matrix = heli_body[0].mesh.GetLocatorTransform("loc_tail_rotor");
        Matrix tail_rotor_rot;
        tail_rotor_rot.RotateX(heli_rotor_angle);

        heli_tail_rotot[0].mesh.SetTransform(tail_rotor_rot * loc_matrix);
    }

    void HitObject(Vector3&in hit, string&in object_name, int object_index)
    {
        for (int i = 0; i<pools.get_length();i++)
        {
            if (pools[i].CheckHit(hit, 1, object_name, object_index))
            {
                break;
            }
        }
    }

    void UpdateBullets(float dt)
    {
        Matrix mat;
        Vector3 hit, normal;
        string object_name;
        int object_index;

        for (int i =  0; i < bullets.get_length(); i++)
        {
            Bullet@ bullet = @bullets[i];

            if (core.scene.Raycast3D(bullet.pos, bullet.dir, dt * bullet_speed, 1, hit, normal, object_name, object_index))
            {
                Vector3 dir = bullet.dir;
                dir.y = 0.0f;
                dir.Normalize();

                HitObject(hit - dir * 3.0f, object_name, object_index);

                core.scene.PlayParticles("Scene", "hit1", hit);

                bullets.removeAt(i);
				i--;
            }
            else
            {
                bullet.pos += bullet.dir * dt * bullet_speed;

                mat = bullet.mesh.GetTransform();
                mat.SetPos(bullet.pos);
                bullet.mesh.SetTransform(mat);
            }
        }
    }

    void UpdateMissiles(float dt)
    {
        Matrix mat;
        Vector3 hit, normal;
        string object_name;
        int object_index;

        for (int i =  0; i < missiles.get_length(); i++)
        {
            Bullet@ missile = @missiles[i];

            if (missile.wait_delete)
            {
                if (!missile.trail.IsSysyemActive())
                {
                    missile.trail.Release();

                    missiles.removeAt(i);
                    i--;
                }

                continue;
            }

            if (core.scene.Raycast3D(missile.pos, missile.dir, dt * missile_speed, 1, hit, normal, object_name, object_index))
            {
                Vector3 dir = missile.dir;
                dir.y = 0.0f;
                dir.Normalize();

                HitObject(hit - dir * 3.0f, object_name, object_index);

                core.scene.PlayParticles("Scene", "hit2", hit);

                if (missile.trail != null)
                {
                    missile.visible = 0;
                    missile.wait_delete = true;
                    missile.trail.SetEmitersActive(false);   
                }
                else
                {
                    missiles.removeAt(i);
				    i--;
                }
            }
            else
            {
                missile.pos += missile.dir * dt * missile_speed;

                mat = missile.mesh.GetTransform();
                mat.SetPos(missile.pos);
                missile.mesh.SetTransform(mat);

                if (missile.trail != null)
                {
                    Matrix trail_mat;
                    trail_mat.SetPos(missile.pos);
                    missile.trail.SetTransform(trail_mat);
                }
            }
        }
    }

    void UpdateCamera(float dt)
    {
        float dir_y = core.controls.GetValue(alias_move_horz, 0);

        if (abs(dir_y) > 0.1f)
        {
            camera_rotate_cur_speed += abs(dir_y) * camera_rotate_accel * dt;

            if (camera_rotate_cur_speed > camera_rotate_speed)
            {
                camera_rotate_cur_speed = camera_rotate_speed;
            }
        }
        else
        {
            if (camera_rotate_cur_speed > 0.0f)
            {
                camera_rotate_cur_speed -= camera_rotate_deaccel * dt;

                if (camera_rotate_cur_speed < 0.0f)
                {
                    camera_rotate_cur_speed = 0.0f;
                }
            }
        }

        if (camera_rotate_angle > heli_angle)
        {
            camera_rotate_angle -= (0.5f + camera_rotate_cur_speed) * dt;

            if (camera_rotate_angle < heli_angle)
            {
                camera_rotate_angle = heli_angle;
            }
        }
        else
        {
            camera_rotate_angle += (0.5f + camera_rotate_cur_speed) * dt;

            if (camera_rotate_angle > heli_angle)
            {
                camera_rotate_angle = heli_angle;
            }
        }

        Vector2 offset = Vector2(sin(-camera_rotate_angle) * 25.0f, cos(-camera_rotate_angle) * 25.0f) * (heli_pos.y / heli_height);
        camera.SetPosTarget(Vector3(cos(camera_vert_angle) * camera_dist_horz + offset.x + heli_pos.x, camera_dist_vert, sin(camera_vert_angle) * camera_dist_horz + offset.y + heli_pos.z), Vector3(offset.x + heli_pos.x, 0.0f, offset.y + heli_pos.z));
    }

    void NextMission(bool forward = true)
    {
        int count = missions.get_length();

        do
        {
            if (forward)
            {
                cur_mission++;

                if (cur_mission == missions.get_length())
                {
                    cur_mission = 0;
                }
            }
            else
            {
                cur_mission--;

                if (cur_mission < 0)
                {
                    cur_mission =  missions.get_length() - 1;
                }
            }

            count--;
        }
        while (count > 0 && missions[cur_mission].IsCompleted());
    }

    void UpdateMissions(float dt)
    {
        int count = 0;

        for (int i = 0; i < missions.get_length(); i++)
        {
            auto@ mission = missions[i];

            if (mission.IsCompleted())
            {
                if (cur_mission == i)
                {
                    NextMission();
                }
                continue;
            }

            mission.SetAsCurrent(cur_mission == i);
            mission.Update(dt);

            count++;
        }

        if (count == 0)
        {
            core.render.DebugText(30, 5, "Return to base");

            Vector3 res;
            core.render.TransformToScreen(main_helipad_pos, res, Vector2(35.0f), Vector2(45.0f));
            float scale = core.render.GetHeight() / 1024.0f;

            core.render.DebugText(res.x * scale, res.y * scale, "X");

            CheckIfCanLand(main_helipad_pos, dt);
        }
    }

    void Update(float dt)
    {
        UpdateMissions(dt);

        UpdateHeli(dt);

        UpdateCamera(dt);

        UpdateBullets(dt);

        UpdateMissiles(dt);

        UpdateParticles(dt);
    }
}